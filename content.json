{"meta":{"title":"F","subtitle":"程序猿随笔 O(∩_∩)O","description":"Java | Data Structure","author":"Flora95","url":"http://flora95.github.io"},"pages":[{"title":"","date":"2016-09-18T07:25:30.324Z","updated":"2016-09-18T07:25:30.214Z","comments":true,"path":"README.html","permalink":"http://flora95.github.io/README.html","excerpt":"","text":"个人博客：http://flora95.github.io/"},{"title":"标签","date":"2015-12-11T14:23:40.000Z","updated":"2016-09-18T07:25:30.384Z","comments":false,"path":"tags/index.html","permalink":"http://flora95.github.io/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2015-12-11T14:27:48.000Z","updated":"2016-09-18T07:25:30.622Z","comments":false,"path":"categories/index.html","permalink":"http://flora95.github.io/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2015-12-11T14:29:35.000Z","updated":"2016-09-18T07:25:30.743Z","comments":false,"path":"about/index.html","permalink":"http://flora95.github.io/about/index.html","excerpt":"","text":""}],"posts":[{"title":"【掌赢后台在线笔试】 网络聊天室","slug":"Chat-Room-NIO","date":"2016-09-19T10:43:49.000Z","updated":"2016-09-19T13:07:42.279Z","comments":true,"path":"Chat-Room-NIO/","link":"","permalink":"http://flora95.github.io/Chat-Room-NIO/","excerpt":"前段时间做了掌赢后台的一个在线笔试题——网络聊天室，题目比较开放，给24个小时进行答题，主要是看笔试者的代码风格习惯。其题目要求和实现方案如下。","text":"前段时间做了掌赢后台的一个在线笔试题——网络聊天室，题目比较开放，给24个小时进行答题，主要是看笔试者的代码风格习惯。其题目要求和实现方案如下。 题目服务端机试题目(Java/C/C++/Go) 实现一个简单的网络聊天室服务端,功能要求如下: 1） 实现服务端(命令行即可,不需要图像UI,使用TCP); 2） 客户端通过telnet连接至服务端; 3） 使用NIO模式; 4） 超时处理:用户超过60S无输入,自动断开连接; 5） 客户端初次连接时服务端返回提示信息,提示用户输入用户昵称;用户输入昵称后,按回车键发送至服务器,如果此昵称已经有其他人用,提示重新输入;如果昵称唯一,则登录; 6） 客户端登录后,输入任何abcd等普通字符,按回车键发送至服务器;当客户端输入‘/quit’并回车时(‘/‘表示此输入是命令),断开连接; 7） 服务器接收客户登录,保证客户昵称唯一即可;用户登录后发送已经设置好的欢迎信息和在线人数给客户端; 8） 服务器收到已登录用户的输入内容,然后在内容前面加上发送方的昵称和分号,转发至其他所有登录客户端,不回发给发送此内容的客户端; 9） 有客户端上线或者下线时,发送通知到所有在线用户,通知内容为“xx已上线”,“xx已下线”; 10） 考虑服务端如果需要支持10万以上级别客户端登录的情况; 11） 各种数据不需要存磁盘; 12） 请看完下一题再开始写代码; 在上一题的基础上,实现自动查询机器人服务,功能要求如下: 1） 实现天气查询服务,客户端输入:”/天气 北京”,服务端调用接口获取北京天气信息返回给客户端;第一个词为查询词(‘/‘表示此输入是命令),后一个为查询关键词,查询类的输入内容,不用发给其他用户; 2） 程序结构需要设计灵活,将来增加查询股票、火车票、飞机票等功能;比如查询火车票的查询格式为:”/火车票 北京 上海”,即可查询北京到上海的火车票情况; 3） 需要有缓存机制,比如城市天气信息,相同城市缓存2小时,减少对接口的调用次数; 4） 如果需要实现查询功能的动态增减,给出解决办法说明,不需要写出代码; 给出文档说明,要求如下: 1) 程序设计的思路; 2) 系统还有哪些改进点; 3) 如果系统支撑的用户数量扩大100 倍,如何处理; 注意：此机试答案需提交代码（上传压缩包）和文档 实现服务端实现 用户信息：服务端维护两个map。一个是用户IP地址至用户名的映射，用于保证在线用户昵称的唯一性。另一个是用户IP地址至用户上次活跃时间的映射，用于辅助Timer实现超时处理。 超时处理：使用Timer实现，每隔一秒检测用户列表，若用户上次活跃时间在60s之前，则强制用户下线。 查询服务：采用策略模式。需要增加新的服务类型时，只需编写新类并实现QueryServiceInterface接口，无需修改现有代码。 针对大用户量的处理方案：现有服务端代码使用一个线程处理所有的用户连接请求和消息，当用户量很大时，可能导致较高的延迟。可以改用线程池，当新的用户请求或消息到达时，从线程池中获取一个新线程进行处理，处理完毕则释放线程。 服务端具体代码如下（若对NIO如何实现网络通信不熟悉，可以参考笔者另一篇博文如何使用Java NIO）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241public class ChatRoomServer &#123; private Selector selector = null; private static final int PORT = 8216; private static final int BUFF_SIZE = 1024; private static final String MSG_USER_EXIST = \"User name exist! Please try again!\"; private static final String MSG_QUERY_FAIL = \"Query failed\"; private static final String CMD_QUIT = \"quit\"; private Charset charset = Charset.forName(\"UTF-8\"); // 记录当前在线用户：用户IP地址-用户名的映射 private static Map&lt;SocketAddress, String&gt; users = new HashMap&lt;SocketAddress, String&gt;(); // 用户IP地址-用户上次活跃时间的映射 private static Map&lt;SocketAddress, Date&gt; activeTime = new HashMap&lt;SocketAddress, Date&gt;(); // 超时处理计时器 private static final Timer TIMER = new Timer(); private static final long TIMER_DELAY_MILLIS = 2000; private static final long TIMER_PERIOD_MILLIS = 1000; private static final long TIMEOUT_MILLIS = 60000; private void init() throws IOException &#123; // 初始化计时器 TIMER.scheduleAtFixedRate(new TimeoutTask(), TIMER_DELAY_MILLIS, TIMER_PERIOD_MILLIS); // 初始化服务端channel，开始监听 selector = Selector.open(); ServerSocketChannel ssc = ServerSocketChannel.open(); ssc.socket().bind(new InetSocketAddress(PORT)); ssc.configureBlocking(false); ssc.register(selector, SelectionKey.OP_ACCEPT); System.out.println(\"Server is listening to port \" + PORT + \" now...\"); while (true) &#123; int ready = selector.select(); if (ready == 0) &#123; continue; &#125; Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys(); Iterator&lt;SelectionKey&gt; keyIterator = selectedKeys.iterator(); while (keyIterator.hasNext()) &#123; SelectionKey key = (SelectionKey) keyIterator.next(); processKey(ssc, key); keyIterator.remove(); &#125; &#125; &#125; private void processKey(ServerSocketChannel ssc, SelectionKey key) throws IOException &#123; // 新用户连接 if (key.isAcceptable()) &#123; SocketChannel sc = ssc.accept(); sc.configureBlocking(false); // 将新连接注册到selector中，用于读取该用户的后续消息 sc.register(selector, SelectionKey.OP_READ); // 重置当前的channel，以便接收其他用户的登录请求 key.interestOps(SelectionKey.OP_ACCEPT); System.out.println(\"Server accepted connection from client: \" + sc.getRemoteAddress()); sc.write(charset.encode(\"Please enter your name: \")); &#125; // 已登录用户消息 else if (key.isReadable()) &#123; SocketChannel sc = (SocketChannel) key.channel(); ByteBuffer buffer = ByteBuffer.allocate(BUFF_SIZE); StringBuffer msg = new StringBuffer(); try &#123; while (sc.read(buffer) &gt; 0) &#123; buffer.flip(); msg.append(charset.decode(buffer)); buffer.clear(); &#125; // 重置当前的channel，以便接收该用户的后续消息 key.interestOps(SelectionKey.OP_READ); if (msg.length() &lt;= 0) &#123; return; &#125; System.out.println(\"Server received message from client \" + sc.getRemoteAddress() + \": [\" + msg + \"]\"); &#125; catch (IOException e) &#123; key.cancel(); if (key.channel() != null) &#123; key.channel().close(); &#125; &#125; processMsg(sc, msg); &#125; &#125; private void processMsg(SocketChannel sc, StringBuffer msg) throws IOException &#123; if (msg == null || msg.length() &lt;= 0) &#123; return; &#125; SocketAddress address = sc.getRemoteAddress(); activeTime.put(address, new Date()); if (msg.charAt(0) == '/' &amp;&amp; msg.length() &gt; 1) &#123; processCmd(sc, msg.substring(1)); return; &#125; // 已登录用户，广播消息 if (users.containsKey(address)) &#123; String userName = users.get(address); String broadcastMsg = userName + \": \" + msg.toString(); broadcastMsg(address, broadcastMsg); &#125; // 新登录用户 else &#123; // 昵称已存在 if (users.containsValue(msg.toString())) &#123; sc.write(charset.encode(MSG_USER_EXIST)); &#125; // 登录用户，返回欢迎信息，广播上线消息 else &#123; users.put(address, msg.toString()); String welcomeMsg = \"Welcome to the chat room, \" + msg + \"! Current online user number is: \" + users.size(); sc.write(charset.encode(welcomeMsg)); broadcastMsg(address, \"User \" + msg + \" online!\"); &#125; &#125; &#125; private void processCmd(SocketChannel sc, String cmd) throws IOException &#123; if (cmd.length() == 0) &#123; return; &#125; // 退出命令 if (cmd.equals(CMD_QUIT)) &#123; logout(sc.getRemoteAddress()); &#125; // 查询命令 else &#123; String[] tokens = cmd.split(\" \"); String queryType = tokens[0]; String[] paras = new String[tokens.length - 1]; for (int i = 1; i &lt; tokens.length; i++) &#123; paras[i - 1] = tokens[i]; &#125; QueryServiceInterface queryService; String result = MSG_QUERY_FAIL; switch (queryType) &#123; case \"天气\": queryService = new QueryWeatherService(); result = queryService.query(paras); break; &#125; sc.write(charset.encode(result)); &#125; &#125; private void broadcastMsg(SocketAddress address, String msg) throws IOException &#123; for (SelectionKey key : selector.keys()) &#123; if (!(key.channel() instanceof SocketChannel)) &#123; continue; &#125; SocketChannel targetChannel = (SocketChannel) key.channel(); SocketAddress targetAddress = targetChannel.getRemoteAddress(); // 不回发给已下线用户 if (!users.containsKey(targetAddress)) &#123; continue; &#125; // 不回发广播消息给发送此内容的客户端 if (address != null &amp;&amp; targetAddress.equals(address)) &#123; continue; &#125; // 执行转发 targetChannel.write(charset.encode(msg)); &#125; &#125; private void logout(SocketAddress address) throws IOException &#123; String msg = \"User \" + users.get(address) + \" offline!\"; broadcastMsg(address, msg); users.remove(address); System.out.println(msg); &#125; public static void main(String[] args) throws IOException &#123; new ChatRoomServer().init(); &#125; /** * 超时处理计时器任务类 * @author Flora95 * */ class TimeoutTask extends TimerTask &#123; @Override public void run() &#123; Date now = new Date(); Iterator&lt;Entry&lt;SocketAddress, Date&gt;&gt; iterator = activeTime.entrySet().iterator(); while (iterator.hasNext()) &#123; Entry&lt;SocketAddress, Date&gt; entry = iterator.next(); Date activeDate = entry.getValue(); if (now.getTime() - activeDate.getTime() &gt;= TIMEOUT_MILLIS) &#123; try &#123; logout(entry.getKey()); &#125; catch (IOException e) &#123; throw new RuntimeException(e); &#125; iterator.remove(); &#125; &#125; &#125; &#125;&#125; 客户端实现客户端实现较为简单，使用SocketChannel向服务端发送连接请求后，创建一个线程用于接收服务端的消息，而主线程则用于从命令行读取用户输入并发送。接收服务端消息的线程实现类似于服务端消息处理的实现，以下仅贴出主线程的实现代码： 123456789101112131415161718192021222324public void init() throws IOException &#123; selector = Selector.open(); // 连接服务端 sc = SocketChannel.open(new InetSocketAddress(HOSTNAME, PORT)); sc.configureBlocking(false); sc.register(selector, SelectionKey.OP_READ); // 启动一个线程接受服务端返回的消息 new Thread(new ClientThread()).start(); // 主线程用于从console读取用户输入并发送到服务端 Scanner scanner = new Scanner(System.in); while (scanner.hasNextLine()) &#123; String line = scanner.nextLine(); if (line.length() == 0) &#123; continue; &#125; sc.write(charset.encode(line)); &#125;&#125; 完整代码获取如果想要亲自试验上述代码，欢迎前往Github下载。 占坑关于第二条要求客户端通过telnet连接至服务端，本人在win10系统使用cmd执行telnet 127.0.0.1 8216命令可以连接至服务端，但是由于连接后的通信不支持回车发送，每次敲击一个字符后该字符都会被立即发送到服务端，因此未能正常测试telnet连接。之后解决了字符发送问题后回来填坑。","categories":[{"name":"面经","slug":"面经","permalink":"http://flora95.github.io/categories/面经/"}],"tags":[{"name":"NIO","slug":"NIO","permalink":"http://flora95.github.io/tags/NIO/"},{"name":"笔试","slug":"笔试","permalink":"http://flora95.github.io/tags/笔试/"}],"keywords":[{"name":"面经","slug":"面经","permalink":"http://flora95.github.io/categories/面经/"}]},{"title":"【Java】如何使用Java NIO","slug":"java-nio","date":"2016-09-18T01:07:42.000Z","updated":"2016-09-19T13:07:01.906Z","comments":true,"path":"java-nio/","link":"","permalink":"http://flora95.github.io/java-nio/","excerpt":"前段时间投了掌赢公司的服务端开发实习，其在线笔试题要求实现一个简单的网络聊天室的服务端，并要求使用NIO。于是笔者便借此机会了解了一下Java NIO的实现，以及它与传统Java IO的不同之处。本文主要包含NIO的基本知识，掌赢在线笔试题的要求及具体实现见博文【掌赢后台在线笔试】 网络聊天室。","text":"前段时间投了掌赢公司的服务端开发实习，其在线笔试题要求实现一个简单的网络聊天室的服务端，并要求使用NIO。于是笔者便借此机会了解了一下Java NIO的实现，以及它与传统Java IO的不同之处。本文主要包含NIO的基本知识，掌赢在线笔试题的要求及具体实现见博文【掌赢后台在线笔试】 网络聊天室。 I/O与NIO的区别在JDK1.4之前，Java中的I/O实现是基于流和装饰器模式的。在java.io.*包的架构中有两类基础类，一类是面向字节的InputStream和OutputStream，一类是兼容Unicode与面向字符的Reader和Writer。而在这两类基础类的继承结构中又分别有与其相对应的FilterInputStream、FilterOutputStream、FilterReader和FilterWriter，这些不同的filter类就是java.io.*包中不同继承树上各装饰器的基类。因此，为了符合应用程序的需要，我们在使用传统I/O时总是要嵌套的创建多个不同的流对象，如BufferedReader reader = new BufferedReader(new InputStreamReader(new FileInputStream(&quot;filename&quot;))); 在JDK1.4中，引入了面向通道和缓冲的NIO，由于此种机制与操作系统底层处理I/O的方式非常类似，所以NIO相较于之前的流I/O来说性能上有很大的提升。同时，NIO中的通道和缓冲区的创建方式比流I/O更方便快捷。值得注意的是，java.io.*包已使用NIO进行重新实现以实现更快的处理速度和更好的集成。 NIO的核心：通道与缓冲区通道通道即Channel，是一个包含数据的矿藏，我们可以通过它来读取和写入数据，与之前的I/O比较的话，通道就像是流。但，我们并不会像与流相互一样直接与通道进行交互，即，我们并不会直接从通道中读取数据或向通道中写入数据，而是要通过缓冲区。通道与流的另外一个不同点是，流是单向的（因此既需要InputStream，又需要OutputStream），而通道是双向的，因此通道比流更能反映底层操作系统的真实情况。 缓冲区正如上一段中所提到的，我们与通道的交互需要通过缓冲区来进行。在执行读操作时，需先将数据从通道读入缓冲区中，再从缓冲区中获取数据；在执行写操作时，需先把数据存入缓冲区，再将数据从缓冲区写入通道。 缓冲区实质上是一个数组，它提供了对数据的结构化访问。最常用的缓冲区类型是ByteBuffer，它提供对原始字节形式和基本数据类型的支持，可以通过get/set方法来对其底层的数组进行操作。其它的缓冲区类型包括CharBuffer、ShortBuffer、IntBuffer、LongBuffer、FloatBuffer和DoubleBuffer，这些缓冲区类所包含的操作完全一样，唯一不同的是它所支持的基本数据类型。但值得注意的是，ByteBuffer可以通过调用类似asCharBuffer()的方法来转换为其他类型的缓冲区，同时它本身也可以通过调用类似putInt/getInt等方法来实现对基本数据类型的支持。 使用NIO进行读写操作如上所述，在使用NIO进行读写操作时，需要首先创建通道和缓冲区对象。修改过后的旧I/O类库中有三个类可以用来产生通道，分别是FileInputStream、FileOutputStream和RandomAccessFile。注意面向字符的Reader和Writer并不能用于产生通道。 下面是一个使用NIO来执行文件复制操作的例子，相关说明见代码注释。 123456789101112131415161718192021222324252627FileInputStream fin = new FileInputStream(\"srcFile\");FileOutputStream fout = new FileOutputStream(\"dstFile\");// 获取通道对象FileChannel fcin = fin.getChannel();FileChannel fcout = fout.getChannel();// 创建缓冲区ByteBuffer buffer = ByteBuffer.allocate(1024);while (true) &#123; // 清空缓冲区，以便进行下一次读操作 buffer.clear(); // 读取数据 int r = fcin.read(buffer); // 文件末尾，退出循环 if (r == -1) break; // 重设缓冲区，以便执行写操作 buffer.flip(); // 写入数据 fcout.write(buffer);&#125; 缓冲区的内部细节从上面文件复制的代码示例中可以发现，在使用ByteBuffer进行读写操作时，无需指明缓冲区的大小和数组索引值，也无需指定所需读写的字节数，但在调用read或write方法之前，需要调用一些其他的方法对缓冲区进行设置，如clear和flip。这些都是由NIO缓冲区的内部实现机制导致的，它通过维护一些状态变量和访问方法封装了相关的统计操作，从而简化了对read和write方法的调用。 状态变量 缓冲区内部维护了四个状态变量，用于指定缓冲区在任意时刻的状态。 position：指向缓冲区底层数组中下一个可供读写操作的位置索引。即，在读操作中，position指向下一个可读字节的位置；在写操作中，position指向下一个字节应写入的位置。 limit：指定缓冲区底层数组所包含的数据数量。position总是不大于limit。 capacity：缓冲区可包含的最大数据数量。limit总是不大于capacity。 mark：标记值，通过调用mark()方法设置，在调用reset()方法时会将position值置为mark的值。 在了解了这四个状态变量之后，我们再来看一下clear和flip方法的语义： clear()：清空缓冲区，为接下来的读操作做准备，limit = capacity; position = 0; flip()：重设缓冲区，为接下来的写操作做准备，limit = position; position = 0; 因此，在文件复制的代码示例中，对clear和flip方法的调用是必不可少的，否则读写操作将无法正常进行。 访问方法 ByteBuffer类提供了若干种get()和put()方法来直接访问缓冲区中的数据。这些方法可以分为相对和绝对两种。 相对方法：如get(byte dst[])，缓冲区在实现此类方法时需服从position和limit的值，且方法操作完成后会更新position值 绝对方法：如put(int index, byte b)，此类方法通过方法参数直接指明了要操作的数组下标索引值，因此与position和limit值无关，当然也就不会在方法中更新这些状态变量。 缓冲区的应用分片slice()方法可以提取现有缓冲区中的一部分，用来创建出一个新的缓冲区。代码示例如下： 12345678ByteBuffer buffer = ByteBuffer.allocate(10);// 通过设置缓冲区的position和limit值来指定分片的范围buffer.position(3);buffer.limit(7);// 获得缓冲区分片ByteBuffer slice = buffer.slice(); 值得注意的是，原缓冲区和分片缓冲区是共享底层数组数据的。也就是说，若在上述代码示例中更改slice缓冲区中的值，buffer缓冲区中相应位置的值也会随之改变。 分片技术对于促进抽象很有帮助。如果只允许某个函数处理缓冲区中的部分数据，则可以给该函数传递一个仅包含所需数据段的分片缓冲区。此种实现比给函数传递额外的参数来指定要处理的缓冲区数据范围更加简便，同时安全性也更高。 只读缓冲区asReadOnlyBuffer()方法允许将一个缓冲区转换成只读缓冲区，从而实现对数据的保护。只读缓冲区与原缓冲区的数据也是共享的。 直接缓冲区通常我们创建缓冲区对象时使用的是ByteBuffer.allocate(size)方法，实际上，还可以使用ByteBuffer.allocateDirect(size)方法来创建直接缓冲区，以进一步的提高I/O速度。在实现上，JVM将尽可能的直接对直接缓冲区执行本机I/O操作，即，它会在每一次调用底层操作系统的本机I/O操作之前或之后，尽量避免直接缓冲区与某一个中间缓冲区之间的数据转移。 内存映射文件FileChannel的map()方法允许创建一个内存映射文件，用来简化对大尺寸文件的处理。map()方法的参数分别为映射模式、起始索引、映射长度。 MappedByteBuffer mbb = channel.map(FileChannel.MapMode.READ_WRITE, 0, 1024) MappedByteBuffer是ByteBuffer的子类，它具有ByteBuffer的所有方法。 NIO实现文件锁定JDK1.4还引入了文件加锁机制，它允许我们同步访问作为共享资源的文件。Java的文件加锁是直接映射到底层操作系统的加锁工具上的，因此，Java的文件锁对其他的操作系统进程也是可见的。其使用方法如下： 12345678910// lock方法是阻塞的，也可以调用非阻塞的tryLock()方法，两方法的参数列表一致FileLock lock = fileChannel.lock(start, end, isShared);// 无参数的方法可以获取整个文件上的锁// FileLock lock = fileChannel.lock();// 执行相关文件读写操作// 释放锁lock.release(); 注意，只有FileChannel有加锁的需求。SocketChannel、DatagramChannel和ServerSocketChannel并不需要加锁，因为它们是从单进程实体继承而来的。 由于不同操作系统实现文件锁的方式不同，如果操作系统不支持共享锁并为每一个请求都创建一个锁，那么它就会使用独占锁。锁的共享或独占类型可以通过调用FileLock.isShared()来查询。 网络通信与异步I/O异步I/O异步I/O是一种无阻塞的读写数据的方式。类似观察者模式，通过注册对特定I/O事件的兴趣，如可读数据的到达或新的套接字连接，就可以在相应事件发生时收到系统的通知。通过异步I/O，我们可以监听任何数量的通道上的事件，而无需进行轮询，也不需要额外的线程。 异步I/O的一个典型应用是网络通信。 使用NIO实现网络通信以下代码示例展示了如何使用NIO来进行网络通信。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253ByteBuffer buffer = ByteBuffer.allocate(1024);// 创建selector，它是注册各种I/O事件兴趣的地方，当相应事件发生时，由该selector对象来通知Selector selector = Selector.open();// 创建ServerSocketChannel接收连接，一个ssc对应一个监听端口ServerSocketChannel ssc = ServerSocketChannel.open();// 必须，使得异步I/O能够工作ssc.configureBlocking(false);// 绑定端口ServerSocket ss = ssc.socket();ss.bing(new InetSocketAddress(port));// 注册，OP_ACCEPT为新连接建立事件，是适用于ServerSocketChannel的唯一事件类型// selector将通过提供对应于注册事件的key来通知事件的发生，key还可用于取消注册SelectionKey key = ssc.register(selector, SelectionKey.OP_ACCEPT);while (true) &#123; // 阻塞直至有已注册事件发生 int num = selector.select(); // 获取已发生事件的SelectionKey对象的集合 Set selectedKeys = selector.selectedKeys(); Iterator it = selectedKeys.iterator(); // 依次处理I/O事件 while (it.hasNext()) &#123; SelectionKey key = (SelectionKey) it.next(); // 新连接事件 if ((key.readyOps() &amp; SelectionKey.OP_ACCEPT) == SelectionKey.OP_ACCEPT) &#123; ServerSocketChannel ssc = (ServerSocketChannel) key.channel(); SocketChannel sc = ssc.accept();// 此处无需担心阻塞 sc.configureBlocking(false); // 将新连接注册到selector中，用于读取数据 SelectionKey newKey = sc.register(selector, SelectionKey.OP_READ); // 删除处理过的SelectionKey，以防止在下次循环中试图再次处理它 it.remove(); &#125; else if ((key.readyOps() &amp; SelectionKey.OP_READ) == SelectionKey.OP_READ) &#123; SocketChannel sc = (SocketChannel) key.channel(); // 读取数据并处理 buffer.clear(); int r = sc.read(buffer); // ... it.remove(); &#125; &#125;&#125;","categories":[{"name":"IO","slug":"IO","permalink":"http://flora95.github.io/categories/IO/"}],"tags":[{"name":"IO","slug":"IO","permalink":"http://flora95.github.io/tags/IO/"},{"name":"channel","slug":"channel","permalink":"http://flora95.github.io/tags/channel/"}],"keywords":[{"name":"IO","slug":"IO","permalink":"http://flora95.github.io/categories/IO/"}]},{"title":"【Java】类文件结构","slug":"Class-File-Structure","date":"2016-06-29T12:49:48.000Z","updated":"2016-09-18T07:25:32.565Z","comments":true,"path":"Class-File-Structure/","link":"","permalink":"http://flora95.github.io/Class-File-Structure/","excerpt":"我们都知道，Java语言是平台无关的，原因在于它是由JVM执行，而并不直接运行于特定的硬件平台之上。而实际上并不只有Java语言能够在JVM上运行，Scala、Jython、JRuby等语言同样可以运行于JVM之上。那么这种平台和语言的无关性是如何实现的呢？答案正是字节码。在将不同的语言编译成符合JVM规范的字节码之后，JVM就可以载入和执行这些字节码，从而实现语言和平台的无关性。","text":"我们都知道，Java语言是平台无关的，原因在于它是由JVM执行，而并不直接运行于特定的硬件平台之上。而实际上并不只有Java语言能够在JVM上运行，Scala、Jython、JRuby等语言同样可以运行于JVM之上。那么这种平台和语言的无关性是如何实现的呢？答案正是字节码。在将不同的语言编译成符合JVM规范的字节码之后，JVM就可以载入和执行这些字节码，从而实现语言和平台的无关性。 JVM与class类文件为了实现平台和语言的无关性，JVM只与class文件这一种特定的二进制文件格式相关联，该文件中包含了JVM指令集、符号表以及若干其他的辅助信息。同时，基于安全方面的考虑，JVM规范要求在class文件中使用许多强制性的语法和结构化约束。 本文接下来的篇幅将依据《深入理解Java虚拟机》一书来具体介绍class文件的结构。其中对数据结构方面的讲解可能会很枯燥，但了解class文件的结构对于深入理解JVM来说是必不可少的。 class类文件结构class文件是一组以8位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑排列，中间没有任何分隔符。这使得整个class文件中存储的几乎都是程序运行的必要数据。当某一个数据项需要占用8位字节以上的空间时，将会按照高位在前的方式将数据项分割为若干个8位字节进行存储。 class文件采用一种类似于C语言结构体的伪结构来存储数据，其只有两种数据类型： 无符号数：用来描述数字、索引引用、数量值或按照UTF-8编码的字符串值。以u1、u2、u4、u8分别表示1个字节、2个字节、4个字节和8个字节的无符号数。 表：由多个无符号数或表作为数据项的复合数据类型。表一般以”_info”结尾。 class文件格式class文件本身其实就是一张表，其格式如下： 类型 名称 数量 u4 magic 1 u2 minor_version 1 u2 major_version 1 u2 constant_pool_count 1 cp_info constant_pool constant_pool_count - 1 u2 access_flags 1 u2 this_class 1 u2 super_class 1 u2 interfaces_count 1 u2 interfaces interfaces_count u2 fields_count 1 field_info fields fields_count u2 methods_count 1 method_info methods methods_count u2 attributes_count 1 attribute_info attributes attributes_count 在上表中可以发现，当需要描述同一类型但数量不定的多个数据时（如interfaces、fields等），通常需要使用一个前置容量计数器加若干个连续数据项的形式，这是由class文件的极度紧凑和结构化约束导致的结果。 示例程序及其对应class文件本文之后对class文件结构的具体解释将基于如下简单示例程序： 12345678public class Test &#123; private int m; public int inc() &#123; return m + 1; &#125;&#125; 将上述Java代码进行编译，并用WinHex打开生成的class文件可得到如下图所示的结果： 魔数 class文件的头4个字节为魔数（Magic Number），其作用是确定文件是否为一个能被虚拟机接受的class文件。很多文件存储标准中都使用魔数来进行身份识别，因为文件的扩展名是可以随意改动的。由图可看出魔数值为0xCAFEBABE。 class文件版本 接着4个字节存储的是class文件的版本号，前两个字节为次版本号（Minor Version），后两个字节为主版本号（Major Version）。高版本的JDK能向下兼容以前版本的class文件，但无法运行以后版本的class文件，即使class文件格式并未发生任何变化，虚拟机也必须拒绝执行超过其版本号的class文件。 由图可见，该class文件的次版本号为0x0000，主版本号为0x0033，也即十进制的51，因此该文件可以被JDK1.7及以上版本的JVM执行。若使用JDK1.6来运行示例Java代码，则会报： 1java.lang.UnsupportedClassVersionError: Bad version number in .class file 常量池常量池格式在class文件版本之后即为常量池入口。常量池可以理解为class文件中的资源仓库，它是class文件中与其他项目关联最多的数据类型，占用空间也最大。 由于常量池中常量的数量并不固定，因此在常量池的入口处有一个u2类型的数据，代表常量池容量计数值（constant_pool_count）。该计数值与class文件中其他表类型的计数值不同的是，其容量计数是从1开始的，因此常量池中实际的常量数为该计数值减去1。如此设计的目的在于满足后面某些指向常量池的索引值的数据在特定情况下需要表达“不引用任何一个常量池项目”的含义，此种情况就可以把相应数据项的索引值置为0。 常量池中主要存放两大类常量： 字面量Literal：类似Java中的常量，如文本字符串、final常量 符号引用Symbolic References：包括类和接口的全限定名（Fully Qualified Name）、字段的名称和描述符、方法的名称和描述符 常量池中每一项常量都是一个表，共有14中不同的表结构类型。这14种表结构开始的第一位都是一个u1类型的标志位（tag），用来表示当前这个常量属于哪一种常量类型。不同的常量类型结构各不相同，其中常量类型的具体含义及结构如下： CONSTANT_Utf8_infoUTF-8编码的字符串，其结构如下： 所含项目 项目类型 项目描述 tag u1 标志位，值为1 length u2 字符串长度 bytes u1 使用UTF-8缩略编码表示的字符串，长度为length CONSTANT_Integer_info整型字面量，其结构如下： 所含项目 项目类型 项目描述 tag u1 标志位，值为3 bytes u4 按照big endian存储的int值 CONSTANT_Float_info浮点型字面量，其结构如下： 所含项目 项目类型 项目描述 tag u1 标志位，值为4 bytes u4 按照big endian存储的float值 CONSTANT_Long_info长整型字面量，其结构如下： 所含项目 项目类型 项目描述 tag u1 标志位，值为5 bytes u8 按照big endian存储的long值 CONSTANT_Double_info双精度浮点型字面量，其结构如下： 所含项目 项目类型 项目描述 tag u1 标志位，值为6 bytes u8 按照big endian存储的double值 CONSTANT_Class_info类或接口的符号引用，其结构如下： 所含项目 项目类型 项目描述 tag u1 标志位，值为7 index u2 索引值，指向CONSTANT_Utf8_info类型常量，表示该类或接口的全限定名 CONSTANT_String_info字符串类型字面量，其结构如下： 所含项目 项目类型 项目描述 tag u1 标志位，值为8 index u2 索引值，指向CONSTANT_Utf8_info类型常量，表示该字符串值 CONSTANT_Fieldref_info字段的符号引用，其结构如下： 所含项目 项目类型 项目描述 tag u1 标志位，值为9 index u2 索引值，指向CONSTANT_Class_info类型常量，表示声明该字段的类或接口描述符 index u2 索引值，指向CONSTANT_NameAndType_info类型常量，表示该字段的描述符 CONSTANT_Methodref_info类中方法的符号引用，其结构如下： 所含项目 项目类型 项目描述 tag u1 标志位，值为10 index u2 索引值，指向CONSTANT_Class_info类型常量，表示声明该方法的类描述符 index u2 索引值，指向CONSTANT_NameAndType_info类型常量，表示该方法的名称和类型描述符 CONSTANT_InterfaceMethodref_info接口中方法的符号引用，其结构如下： 所含项目 项目类型 项目描述 tag u1 标志位，值为11 index u2 索引值，指向CONSTANT_Class_info类型常量，表示声明该方法的接口描述符 index u2 索引值，指向CONSTANT_NameAndType_info类型常量，表示该方法的名称和类型描述符 CONSTANT_NameAndType_info字段或方法的部分符号引用，其结构如下： 所含项目 项目类型 项目描述 tag u1 标志位，值为12 index u2 索引值，指向CONSTANT_Utf8_info类型常量，表示该字段或方法的名称 index u2 索引值，指向CONSTANT_Utf8_info类型常量，表示该字段或方法的描述符 CONSTANT_MethodHandle_info表示方法句柄，其结构如下： 所含项目 项目类型 项目描述 tag u1 标志位，值为15 reference_kind u1 决定方法句柄的类型（1-9之间），表示方法句柄的字节码行为 reference_index u2 对CONSTANT_Utf8_info类型常量的有效索引 CONSTANT_MethodType_info标志方法类型，其结构如下： 所含项目 项目类型 项目描述 tag u1 标志位，值为16 descriptor_index u2 对CONSTANT_Utf8_info类型常量的有效索引，表示方法的描述符 CONSTANT_InvokeDynamic_info表示一个动态方法调用点，其结构如下： 所含项目 项目类型 项目描述 tag u1 标志位，值为18 bootstrap_method_attr_index u2 对引导方法表的bootstrap_methods[]数组的有效索引 name_and_type_index u2 对CONSTANT_NameAndType_info类型常量的有效索引，表示方法名和方法描述符 观察上表第一项，可见CONSTANT_Utf8_info常量类型有一个length属性，其类型为u2。而class文件中的方法、字段等都需要使用该常量类型来描述名称，因此length的最大值就决定了Java中能够定义的方法、字段等的最大长度，也就是65535。当Java程序中定义的方法或字段名超过这个长度时，将无法编译。 解析常量池内容 根据常量池的格式定义，结合上图可知，常量池容量（偏移地址：0x00000008）为0x0013，即19，也就是说常量池中有18个常量。 第1个常量的标志位（偏移地址：0x0000000A）为0A，查上表可知为CONSTANT_Methodref_info类型，其两个index的值分别为0x0004和0x000F，即分别指向常量池的第4和第15个常量。 依据上述过程依次分析class文件，可以解析出常量池中每一个常量的具体含义。但是，采用此种方式查表分析过程不免繁琐，好在我们可以使用一个专门用于分析class文件字节码的工具javap来辅助解析。 在命令行输入 javap -verbose Test 命令后即可获得解析后的常量表，如下图所示。 观察javap的解析结果，会发现常量池中有几项并未在Java程序代码中出现的常量：I、V、init、Code、LineNumberTable等。这些字段是用来描述一些不方便使用“固定字节”进行表述的内容的，它们将在后面要讲到的字段表、方法表、属性表中被引用。 访问标志 在常量池之后，紧接着的两个字节表示访问标志access_flags。该标志描述了一些类或者接口层次的访问信息，具体的标志类型及其含义如下表： 标志名称 标志值 含义 ACC_PUBLIC 0x0001 是否为public类型 ACC_FINAL 0x0010 是否被声明为final类 ACC_SUPER 0x0020 是否允许使用invokespecial指令的新语义 ACC_INTERFACE 0x0200 标识接口 ACC_ABSTRACT 0x0400 是否为abstract类型，接口和抽象类的该标识为真 ACC_SYNTHETIC 0x1000 标识该类并非由用户代码产生 ACC_ANNOTATION 0x2000 标识注解 ACC_ENUM 0x4000 标识枚举 由图可知，Test类的访问标志为0x0021，即ACC_SUPER和ACC_PUBLIC，这一结果在javap的解析结果中也可看出。 继承关系 class文件中使用三类索引来表示类之间的继承关系：类索引（this_class)、父类索引(super_class)以及接口索引集合。其中，类索引和父类索引都为u2类型，而接口索引集合为一组u2类型数据的集合，其容量由接口索引集合的入口项——u2类型的接口计数器interfaces_count表示。 根据类索引查询类名称的过程如下：根据索引值查找类描述符常量CONSTANT_Class_info，再根据CONSTANT_Class_info中的常量索引值查找CONSTANT_Utf8_info类型的常量，解析该常量的内容即可获得类的全限定名字符串。 从class文件偏移地址0x0000009E开始的连续三个u2类型的值为：0x0003、0x0004、0x0000，即类索引为3，父类索引为4，接口索引集合为0。依据javap的解析结果可知，对应的类常量为com/test/Test，父类常量为java/lang/Object。 字段表集合字段表field_info用于描述接口或类中声明的变量，这些变量包括类级变量和实例级变量，而不包括方法内部声明的局部变量。字段表的结构如下表： 类型 名称 含义 u2 access_flags 字段修饰符 u2 name_index 对代表字段简单名称的常量池引用 u2 descriptor_index 对代表字段描述符的常量池引用 u2 attributes_count 额外属性信息的项数 attribute_info attributes 额外属性信息，有attributes_count项 字段修饰符与类的访问标志类似，包括ACC_PUBLIC(0x0001) / ACC_PRIVATE(0x0002) / ACC_PROTECTED(0x0004) / ACC_STATIC(0x0008) / ACC_FINAL(0x0010) / ACC_VOLATILE(0x0040) / ACC_TRANSIENT(0x0080) / ACC_SYNTHETIC(0x1000) / ACC_ENUM(0x4000)。 方法和字段的描述符的作用是描述字段的数据类型、方法的参数列表（包括数量、类型、顺序）和返回值。不同数据类型的标识字符如下表所示。在描述方法时，描述顺序为先参数列表、后返回值，参数列表需按照参数顺序放置在一组小括号”()”之中。例如方法 int indexOf(char[] source, int sourceOffset, int sourceCount, char[] target, int targetOffset, int targetCount, int fromIndex) 的描述符为 ([CII[CIII)I 。 标识字符 含义 标识字符 含义 B byte J long C char S short D double Z boolean F float V void I int L 对象类型 [ 数组类型，一个前置的’[‘代表一个维度 根据上述定义解析该class文件字段表的内容。偏移地址0x000000A4的u2类型变量值0x0001表示该类只有一个字段表数据。接下来的0x0002表示access_flags，即ACC_PRIVATE。然后是两个指向常量池的索引0x0005和0x0006，分别指向常量池的第5项m和第6项I，即该类声明了一个私有的int类型的变量m。而后的0x0000表示该字段表项没有额外的属性信息，字段表内容至此结束。 值得注意的是，在字段表集合中并不会列出从父类或父接口中继承而来的字段，但有可能列出在Java代码中不存在的字段。如在内部类中自动添加的指向外部类实例的字段。 方法表集合class文件中对方法的描述采取了与对字段的描述相同的方式，因此方法表的结构与上一节字段表的结构相同。但是在Java语言中可修饰字段的关键字与可修饰方法的关键字并不一致，因此方法表的访问标志中没有ACC_VOLATILE和ACC_TRANSIENT标志，而新增了ACC_SYNCHRONIZED(0x0020) / ACC_NATIVE(0x0100) / ACC_STRICTFP(0x0800) / ACC_ABSTRACT(0x0400) 标志。另外还有表示方法是否为编译器产生的桥接方法的ACC_BRIDGE(0x0040）标志和表示方法是否接收不定参数的ACC_VARARGS(0x0080)标志。 既然方法表的结构与字段表相同，自然解析的方法也相同。从偏移地址0x000000AE开始，0x0002表示该类共有两个方法。其中第1个方法的访问标志为0x0001，即ACC_PUBLIC，方法名为常量池中的第7个常量&lt;init&gt;，描述符为常量池中的第8个常量()V，其有一个额外属性为0x0009，即Code属性。 从解析结果可以看到，编译器添加了一个在Java代码中并不存在的实例构造器&lt;init&gt;方法。这是编译器比较常见的一种代码添加，另一种代码添加是类构造器&lt;clinit&gt;方法。同时，方法表集合中不会包括未被重写的父类方法。 属性表集合属性表集合即在字段表和方法表集合中出现的attribute_info，其用来描述某些场景专有的信息。JVM规范中预定义的属性一共有21项，如下表所示。 属性名称 使用位置 含义 Code 方法表 Java程序代码编译成的字节码指令 ConstantValue 字段表 final关键字定义的常量值 Deprecated 类、方法表、字段表 声明为deprecated的属性 Exceptions 方法表 方法抛出的异常 EnclosingMethod 类文件 标识局部类或匿名类所在的外围方法 InnerClasses 类文件 内部类列表 LineNumberTable Code属性 Java源码行号与字节码指令的对应关系 LocalVariableTable Code属性 方法的局部变量描述 StackMapTable Code属性 JDK1.6新增，供新的Type Checker检查和处理目标方法的局部变量与操作数栈所需类型是否匹配 Signature 类、方法表、字段表 JDK1.5新增，用于支持泛型情况下的方法签名，避免类型擦除后导致签名混乱 SourceFile 类文件 源文件名称 SourceDebugExtension 类文件 JDK1.6新增，存储额外的调试信息 Synthetic 类、方法表、字段表 标识方法或字段为编译器自动生成 LocalVariableTypeTable 类 JDK1.5新增，使用特征签名代替描述符，以描述泛型参数化类型 RuntimeVisibleAnnotations 类、方法表、字段表 JDK1.5新增，为动态注解提供支持，标识注解运行时可见 RuntimeInvisibleAnnotations 类、方法表、字段表 JDK1.5新增，标识注解运行时不可见 RuntimeVisibleParameterAnnotations 方法表 JDK1.5新增，标识方法参数运行时可见 RuntimeInvisibleParameterAnnotations 方法表 JDK1.5新增，标识方法参数运行时不可见 AnnotationDefault 方法表 JDK1.5新增，记录注解类元素的默认值 BootstrapMethods 类文件 JDK1.7新增，保存invokedynamic指令引用的引导方法限定符 对于集合中的每个属性，其名称由常量池中的一个CONSTANT_Utf8_info常量表示，而属性值的结构则由一个u4的长度属性attribute_length来说明其所占的位数，具体的属性值信息可以进行自定义。 Code属性属于方法表的属性集合，用于存储Java程序方法体中的代码，其结构如下表： 类型 名称 含义 u2 attribute_name_index 指向一个值为”Code”的CONSTANT_Utf8_info常量，表示该属性的名称 u4 attribute_length 属性表的长度 u2 max_stack 操作数栈深度的最大值，JVM将根据该值分配栈帧中的操作数栈深度 u2 max_locals 局部变量表所需的存储空间，单位为Slot（Slot可重用） u4 code_length 字节码长度，JVM规范中规定最大值为65535 u1 code 实际的字节码指令 u2 exception_table_length 显式异常处理表长度 exception_info exception_table 异常处理表 u2 attributes_count 额外属性信息的项数 attribute_info attributes 额外属性信息 字节码指令 根据上述Code属性结构解析class文件中的&lt;init&gt;方法部分，可知其max_stack和max_locals都为0x0001，字节码长度为0x00000005，实际的字节码指令为2A B7 00 01 B1。对于这些字节码指令的解析，可以通过查阅字节码指令表进行翻译，也可以使用javap命令来把解析过程交给计算机。下图显示了javap的解析结果。 12345678public class Test &#123; private int m; public int inc() &#123; return m + 1; &#125;&#125; 看图中的locals和args_size值可以注意到，对于并没有定义任何参数和局部变量的方法而言，其值均为1。这是Java对于实例方法的一个特殊实现，其值1代表的就是指向此方法所属对象的this关键字。当然，若将方法声明为static，那args_size的值就会是0了。 异常表 异常表包含4个u2类型的字段：start_pc / end_pc / handler_pc / catch_type。其联合起来表示的含义为：若字节码在第start_pc行到第end_pc行之间（不包括end_pc行）出现了类型为catch_type或其子类的异常，则转到第handler_pc行进行异常处理。其中，catch_type是一个指向CONSTANT_Class_info类型常量的索引，当该值为0时，代表所有异常类型。 Exceptions属性该Exceptions属性是在方法表中与Code属性平级的一个属性，其不同于上面提到的异常表，它的作用是描述方法可能抛出的受检异常，结构如下表所示。 类型 名称 含义 u2 attribute_name_index 指向一个值为”Exceptions”的CONSTANT_Utf8_info常量，表示该属性的名称 u4 attribute_length 属性表的长度 u2 number_of_exceptions 方法可能抛出的受检异常数 u2 exception_index_table 指向CONSTANT_Class_info类型常量的索引，描述受检异常类型 LineNumberTable属性该属性用于描述Java源码行号与字节码行号的对应关系。它会默认生成到class文件中，以在程序抛出异常时在堆栈中显示出错的行号，同时支持按照源码行来设置断点。 小结关于Java类文件的介绍较长，主要是因为class文件中有许多强制性的语法和结构化约束。但正是class文件所具有的平台中立、紧凑、稳定和可扩展的特点，使得Java技术体系得以实现平台无关、语言无关这两项特性。因此，了解class文件的结构对于深入理解JVM来说是必不可少的。","categories":[{"name":"JAVA&JVM","slug":"JAVA-JVM","permalink":"http://flora95.github.io/categories/JAVA-JVM/"}],"tags":[{"name":".class","slug":"class","permalink":"http://flora95.github.io/tags/class/"},{"name":"JVM","slug":"JVM","permalink":"http://flora95.github.io/tags/JVM/"}],"keywords":[{"name":"JAVA&JVM","slug":"JAVA-JVM","permalink":"http://flora95.github.io/categories/JAVA-JVM/"}]},{"title":"【Java】Java垃圾收集","slug":"Java-Garbage-Collection","date":"2015-12-13T13:40:47.000Z","updated":"2016-09-18T07:25:31.256Z","comments":true,"path":"Java-Garbage-Collection/","link":"","permalink":"http://flora95.github.io/Java-Garbage-Collection/","excerpt":"Java的一大特性就是内存的分配和回收都是自动进行的。当程序规模不大时，我们完全可以不考虑内存的使用情况。但是一旦程序的规模足够大，对性能的要求足够高时，了解Java垃圾收集（GC）的内部机制并根据具体的应用特征来调整使用的垃圾收集算法就显得十分重要了。","text":"Java的一大特性就是内存的分配和回收都是自动进行的。当程序规模不大时，我们完全可以不考虑内存的使用情况。但是一旦程序的规模足够大，对性能的要求足够高时，了解Java垃圾收集（GC）的内部机制并根据具体的应用特征来调整使用的垃圾收集算法就显得十分重要了。 GC属性 吞吐量（Throughput）：程序运行时间 /（程序运行时间 + 垃圾收集时间） 延迟（Latency）：使程序尽可能少的因为垃圾回收而暂停的能力 足迹（Footprint)：GC运行时使用的内存空间 敏捷度（Promptness）：对象被标记为死亡到对象所占内存被回收所经历的时间 影响GC的因素 堆大小 堆内对象的存活率 内存分配速率 引用更新速率 对象的寿命 GC步骤Mark标记阶段，目的是将不可用的对象标记出来，以便进行后阶段的回收。那么，如何判断一个对象是否可用呢？这跟指向该对象的引用有很大的关系。因此，在具体研究对象可用性判定算法之前，让我们先看一看Java中不同的引用类型。 Java引用类型Java中主要有以下四种引用类型： 强引用（Strong Reference）：大多数情况下使用的引用类型。如Object obj = new Object();中的obj就属于强引用。被强引用引用的对象在任何时候都不能被回收。 软引用（Soft Reference）：使用SoftReference类创建的引用，其所引用的对象将在内存空间不足时被回收。 弱引用（Weak Reference）：使用WeakReference类创建的引用，不管内存空间是否足够，其所引用的对象都将在下一次GC时被回收。 虚引用（Phantom Reference）：使用PhantomReference类创建的引用，不影响其所引用的对象的寿命，仅在被回收时收到一个系统通知 上述四种引用的强度由上至下依次减弱。可以看出，除了强引用，其他引用对于GC的执行并无太大的影响。因此，以下讨论中谈到的引用均指强引用。 引用计数算法（Reference Counting） 该算法给每个对象添加一个引用计数器，当有引用指向对象时，计数器加1，当引用失效时，计数器减1。因此，当一个对象的引用计数变为0时，就证明该对象不可用，其所占用的内存也可以立即被释放。 但是主流的Java虚拟机中并没有使用这一简单高效的算法来管理内存，主要原因就是它无法解决循环引用（Circular）的问题。也即，当对象A和对象B相互引用，而没有任何其他对象指向A和B时，由于A和B的引用计数均为1（不等于0），引用计数算法将无法回收这两个对象。 同时，该算法对引用计数的频繁更新也会使得效率降低。 可达性分析算法（Reachability Analysis）从一系列名为”GC Roots”的对象开始向下搜索，就可以形成若干条引用链。如果一个对象到”GC Roots”无任何引用链相连，该对象则被判定为可回收对象。 可以作为GC Roots的对象包括以下几类： 虚拟机栈中引用的对象 方法区中类静态属性引用的对象 方法区中常量引用的对象 Native方法引用的对象 该算法可以很好的解决循环引用的问题。同时，对于高度变化的程序来说比引用计数法效率更高。但是，在迅速发现不可用的对象方面，则没有引用计数法那么快。 Clean Up清理阶段。将Mark阶段标记出的不可用对象清除，释放其所占用的内存空间。主要有以下几种实现方式。 清除（Sweep）算法思想：遍历堆空间，将Mark阶段标记不可用的对象清除。 不足： 效率不高；空间问题，多次清除之后会产生大量的内存碎片。 适用场景：对象寿命长的内存区域。 该算法过程如下图所示： 复制（Copying）算法思想：将内存划分为两个区域（大小比例可调整），每次只用其中一块，当此块内存用完时，就将存活对象复制到另一块内存中，并对当前块进行内存回收。 优点：解决了内存碎片问题；内存分配效率提高。每次复制后对象在堆中都是线性排列的，因此内存分配时只需移动堆顶指针即可。 不足：如果对象的存活率较高，大量的复制操作会显著的降低效率；内存空间浪费，每次都只能使用堆空间的一部分，代价高昂。 该算法过程如下图所示： 整理（Compacting）算法思想：将标记的所有可用对象向内存一端移动，然后直接清理边界以外的内存区域即可。 优点：类似于复制算法，解决了内存碎片问题，内存分配效率提高；消除了复制算法对内存空间的浪费。 不足：难以做到并行。 该算法过程如下图所示： 分代回收（Generational） 前面所述的Mark-Clean算法都是针对整个堆区域的，每一次GC运行都需要对堆中所有的对象进行遍历。因此，随着堆中对象数量的增多，GC的效率就会随之下降。于是，GC对程序运行做出如下假设： 大多数对象都会在创建后不久死亡 如果对象已存活一段时间，那它很可能会继续存活一段时间 基于这两个假设，GC将堆中的对象按照存活时间分为三代：Young（新生代）、Old（老年代）、Perm（永久代）。其内存划分示意图如下： YOUNG 新生代由图可见，新生代又可划分为三个区域：Eden，Survivor0，Survivor1。其中，Eden区最大，新对象的内存分配都在此区域进行。两个Survivor区域一个为From区，一个为To区，每次只使用其中的一个。 新生代的垃圾回收采用的是复制算法。第一次GC时，Eden区的存活对象会被复制到S0区。此后每次进行GC时，Eden区和From区的存活对象都会被复制到To区。如果一个对象在经历了几次垃圾回收后仍然存活，那么它就会被复制到Old Generation（老年代），此过程称为Promotion。 OLD 老年代老年代的对象是由新生代对象经过Promotion而来，基于前面列出的假设：“如果对象已存活一段时间，那它很可能会继续存活一段时间”，该区域的对象存活率普遍较高，因此一般采用Mark-Sweep或Mark-Compact算法。 PERM 永久代永久代并不用来存储从老年代经过Promotion而来的对象，它存储的是元数据，包括已被虚拟机加载的类信息、常量、静态变量、方法等。该区域通常不会发生垃圾回收。 安全点/安全区域在程序执行时，并非任何时候都可以停下来进行垃圾回收，只有到达某些特定的点时才能暂停，这些点称为安全点（Safepoint）。安全点的设定既不能太少以致于让GC等待时间过长，也不能太频繁导致运行时负荷增大。一般在方法调用、循环跳转、异常跳转处会产生安全点。 那么，如何在GC发生时让所有的用户线程都“跑”到最近的安全点上停下来呢，有以下两种方案： 抢先式中断：在GC发生时即中断所有用户线程，若有的线程中断的地方不是安全点，则恢复该线程，让它跑到安全点上再暂停。（几乎不用） 主动式中断：GC在其要开始运行前设置一个标志。而每个用户线程在运行过程中都会去主动的轮询这个标志，如果标志为真则主动中断挂起。由于轮询标志的地方和安全点重合，因此线程暂停的地方一定是安全的。 但是，以上实现方案有一种情况无法解决，那就是用户线程不运行的时候，也即处于sleep或blocked状态的时候。由于此时线程无法轮询中断标志，也就不能保证GC开始时它一定处于安全状态。此时就需要引入安全区域（Safe Region）的概念了，它是指在一段代码片段中，对象之间的引用关系不会发生变化。安全区域可以看做是扩展了的安全点。 当用户线程执行到Safe Region时，首先会标志自己进入了安全区域。那么，就算GC要开始时该线程处于blocked状态，GC也可以放心的执行垃圾回收动作了。而当线程要离开Safe Region时，要先检查GC是否已经完成。如果完成了，线程就可以继续执行，否则需等待直到收到可以安全离开Safe Region的信号为止。 垃圾收集器不同的虚拟机中通常有不止一种的垃圾收集器，它们实现了不同的垃圾收集算法。以下列举在Sun HotSpot虚拟机中包含的垃圾收集器。 YOUNG 新生代 Serial（-XX:+UseSerialGC）单线程收集器，采用复制算法。GC运行时会暂停所有的用户线程（STW，Stop The World）。是虚拟机运行在Client模式下的默认新生代收集器。 ParNew（-XX:+UseParNewGC）Serial收集器的多线程版本，除此之外与Serial收集器几乎完全相同。是许多运行在Server模式下的虚拟机中首选的新生代收集器。原因之一是它是唯一能与CMS配合使用的新生代收集器。 可使用-XX:ParallelGCThreads参数指定垃圾收集的线程数。 Parallel Scavenge（-XX:+UseParallelGC）与ParNew一样，是使用复制算法的多线程收集器。但是不同于ParNew对缩短垃圾收集时用户线程停顿时间的关注，Parallel Scavenge更多的是关注提高程序的吞吐量，因此常被称为“吞吐量优先”收集器。适用于在后台运算而没有太多交互的任务。 OLD 老年代 Serial OldSerial收集器的老年代版本，单线程收集器，使用Mark-Compact算法。 主要用于Client模式下的虚拟机。但在Server模式下也有两大用途。 在JDK1.5及之前版本中与Parallel Scavenge搭配使用 作为CMS收集器的后备预案，在发生Concurrent Mode Failure时使用 Parallel Old（-XX:+UseParallelOldGC）Parallel Scavenge的老年代版本，使用多线程和Mark-Compact算法，JDK1.6开始提供。 下图展示了Serial和Parallel收集器的工作模式。 CMS（-XX:+UseConcMarkSweepGC）Concurrent Mark Sweep，其工作过程可分为以下四个步骤： 初始标记（Initial Mark）：STW方式。标记GC Roots直接引用的对象，时间很短。 并发标记（Concurrent Mark）：进行GC Roots Tracing，标记出所有可用对象。 重新标记（Remark）：对并发标记期间因程序继续运行而变化的引用进行修正，停顿时间比初始标记长，但远比并发标记短。 并发清除（Concurrent Sweep）：清除不可用对象，释放内存。 该过程示意图如下所示： 由图可见，CMS执行过程中大部分阶段都是与用户线程并行进行的，因此用户线程暂停时间会大大减少。但是由于CMS在进行清理时，用户线程也在运行，也即此时仍然会有新的垃圾产生。这些垃圾称为“浮动垃圾”（Floating Garbage）。由于“浮动垃圾”产生于CMS标记阶段之后，它们只能等到下一次GC时才可被回收。所以，CMS并不能等到老年代几乎要满了才开始垃圾收集动作，它必须预留足够的空间给用户线程在垃圾收集过程中使用。如果预留的空间预估不准的话，就有可能出现以下两种情况： Concurrent Mode Failure：在CMS运行期间预留的内存空间不够用户线程使用，这将触发一次Full GC，即启动后备预案（Serial Old收集器）来重新进行老年代的垃圾收集。这可能会导致数分钟的用户线程停顿。 Promotion Failure：由于CMS采用的是Mark-Sweep算法，因此在执行了几次GC之后老年代会存在大量的内存碎片。如果从新生代经过Promotion而来的对象过大，就很有可能找不到足够的空间来分配。这也会提前触发一次Full GC。 可使用-XX:+CMSInitiatingOccupancyFraction参数来指定在老年代空间被使用多少后触发垃圾收集，默认为68%。 G1（Garbage First，-XX:+UseG1GC）之所以把G1单独列出来，是因为它在内存年代划分上不同于上面介绍的所有收集器。G1把内存分为很多个大小相等的独立区域（Region），新生代和老年代不再是相互隔离的，而是都由若干个非连续的Region组成。除此之外，G1收集器还有以下几个特点： 并行与并发：可大大缩短STW的时间 分代收集：G1可以不需要其他收集器的配合而独立管理整个GC堆，而且它能够使用不同的方式去处理不同年代的对象 空间整合：G1整体上采用Mark-Compact算法，消除了内存碎片 可预测的停顿：通过跟踪各个Region中垃圾堆积的价值大小（可回收的空间大小以及回收所需时间的经验值），G1维护了一个优先列表，每次根据允许的收集时间，优先对价值最大的Region进行回收。 当然，由于跨Region引用的存在，垃圾收集并不能真的以Region为单位进行。对于这种情况，G1通过为每一个Region维护一个Remember Set（RSet）来避免进行全堆扫描。RSet中记录了其他Region中的对象指向本Region对象的引用信息。 忽略RSet的维护操作，G1的执行过程主要分为以下四步，其与CMS的执行过程很相似： 初始标记（Initial Mark）：STW方式。标记GC Roots直接引用的对象，并修改TAMS的值，使下一阶段用户线程并发运行时能够在正确可用的Region中创建新对象。时间很短。 并发标记（Concurrent Mark）：进行GC Roots Tracing，标记出所有可用对象。 最终标记（Final Mark）：将并发标记期间因程序继续运行而变化的引用合并到RSet中。 筛选回收（Live Data Counting and Evacuation）：对各个Region按照回收价值和成本进行排序，然后根据用户所期望的GC停顿时间来制定回收计划。 其执行过程如下图所示： GC监控在实际应用中，常常需要根据不同的应用特征调整垃圾收集器的配置方案。在调整过程中，不免需要监控各种收集器的运行过程来进行性能的比较。JDK自带了一个Visual VM工具来可视化GC的执行过程。笔者最近为了跟踪服务器上不同垃圾收集器实现的性能，分析了较多的GC日志。不同收集器生成的日志格式可能不尽相同，但都有一定的共性。下面列出的是在实际应用中使用ParNew+CMS和使用G1时产生的日志，从中可以很清楚的看到CMS和G1的执行阶段以及GC运行时用户线程暂停的时间，有兴趣的朋友可以研究一下（可以右键‘在新标签页中打开图片’查看清晰大图）。 ParNew+CMS日志 G1日志 使用的日志相关参数如下 -verbose:gc-XX:+PrintGCDetails-XX:+PrintGCTimeStamps-XX:+PrintGCDateStamps-XX:+PrintHeapAtGC 其他注意点 避免显式调用System.gc()或Runtime.getRuntime().gc()。这两个方法只是给虚拟机一个建议，是否执行垃圾回收还是由虚拟机来决定。 不要在finalize()方法中释放资源。 不要尝试在finalize()方法中逃脱垃圾回收。","categories":[{"name":"JAVA&JVM","slug":"JAVA-JVM","permalink":"http://flora95.github.io/categories/JAVA-JVM/"}],"tags":[{"name":"GC","slug":"GC","permalink":"http://flora95.github.io/tags/GC/"},{"name":"JVM","slug":"JVM","permalink":"http://flora95.github.io/tags/JVM/"},{"name":"内存","slug":"内存","permalink":"http://flora95.github.io/tags/内存/"}],"keywords":[{"name":"JAVA&JVM","slug":"JAVA-JVM","permalink":"http://flora95.github.io/categories/JAVA-JVM/"}]},{"title":"【Java】Java内存分配 & OutOfMemoryError","slug":"Java-Memory-OOM","date":"2015-12-12T03:22:07.000Z","updated":"2016-09-19T13:06:23.348Z","comments":true,"path":"Java-Memory-OOM/","link":"","permalink":"http://flora95.github.io/Java-Memory-OOM/","excerpt":"相信Java程序猿们在平常写程序的过程中都或多或少的遇到过OutOfMemoryError（OOM）。如果对于Java的运行时数据区完全没有了解的话，要进行错误定位和修复将是一件很困难的事情。下图展示了JVM的结构。","text":"相信Java程序猿们在平常写程序的过程中都或多或少的遇到过OutOfMemoryError（OOM）。如果对于Java的运行时数据区完全没有了解的话，要进行错误定位和修复将是一件很困难的事情。下图展示了JVM的结构。 从图中可以看出，JVM在执行Java程序时会把它所管理的内存划分为若干个不同的区域。这些区域大体上可以分为以下两类： 线程共享区域：由所有的线程共享，在虚拟机进程启动时创建 线程私有区域：依赖用户线程的启动和结束而建立和销毁 下面笔者将逐一介绍各个区域的用途并对可能发生的内存溢出异常情况进行试验。 运行时数据区域程序计数器 PC Registers当前线程所执行的字节码的行号指示器，占用空间很小，属于线程私有的内存。如果线程正在执行的是Java方法，则计数器中存储的是正在执行的虚拟机字节码指令地址；如果正在执行的是Native方法，则计数器中的值为空（Undefined）。 该内存区域是Java虚拟机规范中唯一一个没有规定任何OutOfMemoryError情况的区域。 堆内存 Heap Memory用于存放对象实例，是JVM所管理的内存中最大的一块，由所有线程共享。堆是垃圾收集器管理的主要区域，关于Java垃圾收集的相关内容可以参考笔者另一篇博文Java垃圾收集。 JVM规范规定，堆可以处于物理上不连续的内存空间中，只要逻辑上连续即可。堆的大小可以用参数-Xms和-Xmx来控制，如果在堆中没有内存来完成实例分配，并且堆也无法再扩展时，就会抛出OutOfMemoryError。 栈 Java Stacks描述Java方法执行的内存模型，属于线程私有的内存。每个方法在执行时都会创建一个栈帧（Stack Frame）用来存储局部变量表、操作数栈、动态链接、方法出口等信息。栈帧在JVM中的入栈到出栈过程就反映了方法调用到执行结束的过程。其中，局部变量表存放了编译器可知的各种基本数据类型、对象引用和返回地址类型。由于存放的都是编译器可知数据，因此当进入一个方法时，该方法需要在帧中分配多大的局部变量空间是确定的，在方法运行期间局部变量表的大小不会改变。 在JVM规范中，对该区域规定了两种异常状况： StackOverflowError：线程请求的栈深度大于虚拟机允许的深度 OutOfMemoryError：栈动态扩展时无法申请到足够的内存 本地方法栈 Native Method Stack作用类似于栈，也是线程私有的内存区域。区别在于栈为JVM执行Java方法服务，而本地方法栈为JVM使用的Native方法服务。JVM规范对该区域中方法使用的语言、使用方法和数据结构都没有进行强制规定，因此不同的虚拟机对该区域的实现方式不尽相同。HotSpot虚拟机则干脆将该区域与栈合为一体。 与栈一样，该区域也会抛出StackOverflowError和OutOfMemoryError。 方法区 Method Area用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据，是各个线程共享的内存区域。HotSpot虚拟机使用永久代来实现该区域。 JVM规范对方法区的限制非常宽松，除了和堆一样不需要连续的内存和可以选择固定大小或可扩展外，还可选择不实现垃圾收集。相比堆而言，垃圾收集在该区域较少出现，主要是针对常量池的回收和类型的卸载。当该区域无法满足内存分配需求时，就会抛出OutOfMemoryError。 运行时常量池是方法区中的一部分，用于存储clas文件常量池（包括编译期生成的各种字面量和符号引用）和运行期间产生的常量（如使用String.intern()方法）。由于受到方法区内存的限制，该区域也会抛出OutOfMemoryError。 直接内存并不是虚拟机运行时数据区的一部分，但是也可能出现OutOfMemoryError，因此放在这里一起讲解。 在JDK1.4中新加入的NIO类引入了一种基于通道Channel与缓冲区Buffer的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块堆外内存的引用进行操作。这样可以避免在堆和Native堆中来回复制数据，从而显著提高性能。 虽然直接内存不会受到Java堆内存的限制，但仍然会受到本机总内存以及处理器寻址空间的限制。在配置虚拟机参数时，会根据实际内存设置-Xmx等参数信息，但常常会忽略直接内存，使得各个内存区域总和大于物理内存限制，从而导致动态扩展时出现OutOfMemoryError。 OutOfMemoryError此部分通过若干实例来验证异常发生的场景并简单介绍各异常情况的处理方法。 注意：以下代码开头注释VM Args后的内容为虚拟机启动参数，其对实验结果有直接影响，请调试的时候千万不要忽略。若使用控制台执行程序，则直接将参数加在java命令之后即可。若使用eclipse IDE，则在Run As -&gt; Run Configurations -&gt; Arguments -&gt; VM arguments中设置。 Java堆溢出堆用于存储对象实例，因此可以通过不断的创建对象，并保证对象存活来避免垃圾回收动作，则在对象数量到达最大堆容量限制后就会抛出OutOfMemoryError。 12345678910111213141516171819/** * VM Args: -Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError * 将堆的最小值-Xms和最大值-Xmx参数设为一样使堆不可扩展 * -XX:+HeapDumpOnOutOfMemoryError：使JVM在发生OOM时dump出当前的内存堆转储快照以供分析 */public class HeapOOM &#123; static class TestObject &#123; &#125; public static void main(String[] args) &#123; List&lt;TestObject&gt; list = new ArrayList&lt;TestObject&gt;(); while (true) &#123; list.add(new TestObject()); &#125; &#125;&#125; 其运行结果如下图，可以看出在异常堆栈信息中很明显的提示了”Java heap space”。 要解决堆区域的异常，可先通过内存映像分析工具（如Eclipse Memory Analyzer）对dump出的堆转储快照进行分析，确认内存中的对象是否都是必要的。 内存泄露：即内存中的对象并非都是必要的。可进一步通过工具查看泄露对象到GC Roots的引用链，分析这些对象无法被回收的原因。掌握了这些泄露对象的内存和引用链信息，就比较容易确定泄露代码的位置了。 内存溢出：即内存中的对象都是必要的。则应调整JVM参数来增大堆内存大小，或调整代码缩短部分对象的生命周期了。 JVM栈和本地方法栈溢出本地方法栈大小可用参数-Xoss设置，JVM栈大小可用参数-Xss设置。但是由于HotSpot虚拟机并不区分虚拟机栈和本地方法栈，因此，栈容量只由-Xss参数决定。 从上述讲解中可知，JVM规范对这两个区域规定了以下两种异常状况： StackOverflowError：线程请求的栈深度大于虚拟机允许的深度 OutOfMemoryError：栈动态扩展时无法申请到足够的内存 仔细思考的话，不难看出上述两种异常状态存在着互相重叠的地方：当栈空间无法继续分配时，究竟是内存过小，还是已使用的栈空间过大，这本质上就是一个问题的两个不同角度。 下面分单线程和多线程两种情况来进行测试： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class StackError &#123; // 作用是使test2()在执行new StackError()时不断的在栈中创建StackError对象 private StackError stackError = new StackError(); /* * VM Args: -Xss128k * 措施：设置-Xss参数减少栈内存容量 * 结果：StackOverflowError */ public static void test1() &#123; test1(); &#125; /* * 措施：定义大量本地变量，增大方法帧中本地变量表的长度 * 结果：StackOverflowError */ public static void test2() &#123; new StackError(); &#125; /* * VM Args: -Xss128k * 措施：不断的创建线程，使其耗尽内存抛出异常 * 结果：OutOfMemoryError */ public static void test3() &#123; while (true) &#123; Thread thread = new Thread(new Runnable() &#123; @Override public void run() &#123; while (true) &#123; &#125; &#125; &#125;); thread.start(); &#125; &#125; public static void main(String[] args) &#123; // 单线程 //test1(); test2(); // 多线程 //test3(); &#125;&#125; 注意： 由于在Windows平台的JVM中，Java的线程是映射到操作系统的内核线程上的，因此test3()执行有较大风险，可能会导致操作系统假死。请务必在执行前保存相关工作。 从以上程序的结果可以看出：单线程情况下，无论是由于虚拟机栈容量太小还是栈帧太大，当内存无法分配时，都将抛出StackOverflowError。多线程情况下，通过不断建立线程的方式可以产生OutOfMemoryError，但此种情况下的内存溢出与栈空间大小并无关系，而是受限于操作系统分配给每个进程的内存。 对于StackOverflowError，可以通过错误堆栈信息较方便的找到问题所在。而对于由创建过多线程导致的OutOfMemoryError，在无法减少线程数或更换64位JVM的情况下，就只能通过减少最大堆和方法区的容量来获得更大的栈容量，从而获取更多的线程了。 方法区和运行时常量池溢出方法区用于存放Class的相关信息，因此可以通过在运行时产生大量的类来填充方法区引发内存溢出。以下试验借助了CGLib直接操作字节码来在运行时生成动态类。由于HotSpot虚拟机使用永久代来实现方法区，因此可以使用-XX:PermSize和-XX:MaxPermSize参数来限制方法区的大小。 12345678910111213141516171819202122232425/** * VM Args: -XX:PermSize=10M -XX:MaxPermSize=10M * 结果：OutOfMemoryError */public class MethodAreaOOM &#123; static class TestObject &#123;&#125; public static void main(String[] args) &#123; while (true) &#123; Enhancer enhancer = new Enhancer(); enhancer.setSuperclass(TestObject.class); enhancer.setUseCache(false); enhancer.setCallback(new MethodInterceptor() &#123; @Override public Object intercept(Object obj, Method m, Object[] objects, MethodProxy proxy) throws Throwable &#123; return proxy.invokeSuper(obj, objects); &#125; &#125;); enhancer.create(); &#125; &#125;&#125; 当前的许多主流框架，如Spring、Hibernate，在对类进行增强时，都会使用到CGLib这类字节码技术。另外，JVM上的动态语言也会持续创建类来实现语言的动态性。而一个类要被垃圾收集器回收，其判定条件是非常苛刻的。因此，在经常动态生成大量Class的应用中，要特别注意类的回收情况。 本地直接内存溢出直接内存（Direct Memory）容量可由参数-XX:MaxDirectMemorySize指定，若无指定，则默认与堆最大容量（-Xmx）一致。下面一段代码展示了使用unsafe分配内存来使该区域发生内存溢出的情况（需要import sun.misc.Unsafe）。 123456789101112131415161718192021/** * VM Args: -Xmx20M -XX:MaxDirectMemorySize=10M * */public class DirectMemoryOOM &#123; private static final int _1MB = 1024 * 1024; public static void main(String[] args) throws IllegalArgumentException, IllegalAccessException &#123; // 通过反射获取Unsafe实例 Field unsafeField = Unsafe.class.getDeclaredFields()[0]; unsafeField.setAccessible(true); Unsafe unsafe = (Unsafe)unsafeField.get(null); // 使用unsafe.allocateMemory申请并分配内存 // 若使用DirectByteBuffer进行分配，虽然也会抛出OOM，但实际并未向操作系统申请分配内存，而是通过计算得知内存不够而手动抛出 while (true) &#123; unsafe.allocateMemory(_1MB); &#125; &#125;&#125; 运行结果： 该区域的内存溢出有一个显著的特征：在heap dump文件中不会显示出明显的异常。因此，如果在编程过程中出现OOM后dump文件很小，而程序中又直接或间接的使用了NIO，那就有可能是Direct Memory的问题了。 参考资料《深入理解Java虚拟机：JVM高级特性与最佳实践（第二版）》如果想要亲自试验上述代码，欢迎前往GitHub下载。","categories":[{"name":"JAVA&JVM","slug":"JAVA-JVM","permalink":"http://flora95.github.io/categories/JAVA-JVM/"}],"tags":[{"name":"OOM","slug":"OOM","permalink":"http://flora95.github.io/tags/OOM/"},{"name":"内存","slug":"内存","permalink":"http://flora95.github.io/tags/内存/"}],"keywords":[{"name":"JAVA&JVM","slug":"JAVA-JVM","permalink":"http://flora95.github.io/categories/JAVA-JVM/"}]}]}